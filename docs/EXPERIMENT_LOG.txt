DATE: 14/12/25
Integrator: LeapFrog (sympletic)
dt, steps, softening: dt = 2e-4, timesteps = 5000, softening = 0.0

Scenario:
Two-body Sun–planet system in 2D.
Planet initialized on circular orbit at r = 1 with v = 2π.
Sun given compensating velocity to ensure total linear momentum ≈ 0.
Used as a baseline validation test for conservation laws.

Expected:

Total energy should exhibit small bounded oscillations with no secular drift.
COM-frame angular momentum should be conserved to machine precision.
Linear momentum should remain constant (center of mass stationary).

Observed max energy drift: 

1e-11 (bounded oscillation, no secular trend)

Observed max L_com drift:

1e-15 (machine precision)

Observed max |P| drift:

Not explicitly measured in this test.
COM remains stationary, implying |P| ≈ 0 within numerical precision.

Next action: Add explicit linear momentum and center-of-mass drift diagnostics to complete Phase 2 validation.







DATE: 16/12/25
Integrator: Leapfrog (Velocity Verlet)
dt, steps, softening: dt = 2e-4, steps = 5000, softening = 0.0

Scenario:
Two-body Sun–planet system, near-circular orbit.
Initial total linear momentum ≈ 0.
Measurements taken in diagnostic (time-aligned) state.

Expected:
- Energy: bounded oscillations, no secular drift
- Angular momentum (COM frame): conserved to machine precision
- Linear momentum: 0 up to floating-point noise
- COM position: no systematic drift

Observed max energy drift: 1.6 × 10⁻⁹ (bounded oscillation)

Observed max L_com drift: 2 × 10⁻¹⁵

Observed max |P| drift: 3 × 10⁻¹⁷

Observed COM drift: 1 × 10⁻¹⁷

Conclusion:
Integrator behaves correctly. Conservation laws satisfied to expected numerical precision.

Next action:
Compare to Eulers.






DATE: 16/12/25
Integrator: Euler (Forward Euler)
dt, steps, softening: dt = 2e-4, steps = 5000, softening = 0.0

Scenario:
Two-body Sun–planet system, near-circular orbit.
Same initial conditions as Leapfrog comparison.

Expected:
- Energy: secular (linear) drift
- Angular momentum: secular drift
- Linear momentum: growing error
- Center-of-mass: noticeable drift

Observed max energy drift: 1.5 × 10⁻² (linear growth)

Observed max angular momentum drift: 8 × 10⁻³ (linear growth)

Observed max |P| drift: 4 × 10⁻¹⁷

Observed COM drift: 1.5 × 10⁻¹⁷

Conclusion:
Euler integrator exhibits expected non-conservation of invariants.
Results clearly contrast with Leapfrog and validate diagnostic framework.

Next action:
Use Leapfrog as default integrator.
Proceed to Phase 3 (3D extension).







DATE: 16/12/25
Integrator: Leapfrog (Velocity Verlet, Symplectic)
dt, steps, softening: dt = 2e-4, steps = 5000, softening = 0.0

Scenario:
Two-body Sun–planet system in full 3D.
Initial conditions define a planar near-circular orbit (z = 0, vz = 0), used to validate the 3D extension against the known 2D solution.

Expected:
- Energy: bounded oscillations, no secular drift
- Angular momentum (COM frame): conserved to machine precision
- Linear momentum: 0 up to floating-point noise
- COM position: no systematic drift


Observed max relative energy drift: 1.6 × 10⁻⁹

Observed max angular momentum drift: 2.5 × 10⁻¹⁵

Observed max |P(t)|: 3.5 × 10⁻¹⁷

Observed COM drift: 1.2 × 10⁻¹⁷

Conclusion:
Leapfrog integrator preserves physical invariants in 3D to machine precision.
Energy shows bounded oscillations characteristic of symplectic integration.
Angular momentum magnitude, linear momentum, and center-of-mass remain conserved up to floating-point error, validating the 3D physics, integrator updates, and diagnostic framework.

Next action:
Extend validation with non-planar 3D orbits (z, vz != 0).






DATE: 16/12/25
Integrator: Leapfrog (Velocity Verlet, Symplectic)
dt, steps, softening: dt = 2e-4, steps = 5000, softening = 0.0

Scenario:
Two-body Sun–planet system in full 3D with non-planar initial conditions.
Planet initialized with a small vertical velocity component (vz ≠ 0), producing a tilted 3D orbit.

Expected:

Energy: bounded oscillatory error (no secular drift)

Angular momentum: conserved in magnitude

Linear momentum: small constant offset due to initial conditions

Center-of-mass: linear drift consistent with non-zero total momentum

Observed max relative energy drift: 2.0 × 10⁻⁹

Observed max angular momentum drift: 6.0 × 10⁻¹⁵

Observed max |P(t)|: 1.0 × 10⁻⁴

Observed COM drift: 1.0 × 10⁻⁴

Conclusion:
Leapfrog integrator correctly preserves energy and angular momentum magnitude in fully 3D motion.
The system evolves on a tilted orbit while maintaining bounded energy error and machine-precision angular momentum conservation.
Observed linear momentum and center-of-mass drift are consistent with the intentionally non-zero initial total momentum.
This validates the full 3D physics implementation, integrator updates, and diagnostic framework.

Next action:
Proceed to Phase 4 (Barnes–Hut solver development).






DATE: 18/12/25

Integrator: Leapfrog (Velocity Verlet)
Solver: Barnes–Hut Octree (θ = 0.7)

dt, steps, softening: dt = 2e-4, steps = 5000, softening = 0.0

Scenario:
Two-body Sun–planet system in near-circular orbit.
Same initial conditions used for DirectSolver validation.

Expected:
- Energy: bounded oscillatory error (symplectic integrator)
- Angular momentum: conserved up to floating-point precision
- Linear momentum: small constant offset due to approximate force symmetry
- Center-of-mass: slow drift due to Barnes–Hut approximation

Observed:
- Max relative energy drift: ~2 × 10⁻⁹ (bounded, non-secular)
- Angular momentum drift: ~1 × 10⁻¹⁵ (floating-point noise)
- |P(t)|: ~1 × 10⁻¹⁰, constant after initialization
- Center-of-mass drift: linear, reaching ~1 × 10⁻⁴ over 5000 steps

Conclusion:
Barnes–Hut solver reproduces direct-solver dynamics for small N with bounded energy error under symplectic integration.
Angular momentum conservation is effectively exact.
Small center-of-mass drift is observed, consistent with known Barnes–Hut force asymmetry and expected at this approximation level.

Next actions:
- Validate Barnes–Hut against DirectSolver for moderate N.
- Study accuracy vs performance as a function of θ.
- Proceed to performance-oriented testing (Phase 5).





DATE: 18/12/25

Integrator: Leapfrog (Velocity Verlet)
Solvers: Direct O(N²) vs Barnes–Hut Octree (θ = 0.7)

dt, steps, softening: dt = 2e-3, steps = 2000, softening = 1e-3

Scenario:
Random 3D N-body system (N = 15) with random initial positions, velocities, and masses.
Same initial conditions used for both solvers.

Expected:
- Energy: bounded but noisy due to chaotic dynamics
- Angular momentum: conserved for Direct, approximate for Barnes–Hut
- Linear momentum: near-constant with small fluctuations
- Center-of-mass: similar drift for both solvers

Observed:
- Relative energy drift:
  Direct and Barnes–Hut remain bounded, with step-like changes during close encounters.
- Angular momentum drift:
  Direct remains flat; Barnes–Hut exhibits bounded fluctuations (~10⁻²).
- |P(t)|:
  Direct nearly constant; Barnes–Hut shows small bounded noise.
- Center-of-mass drift:
  Nearly identical between solvers, indicating no major bias from Barnes–Hut.

Conclusion:
For small chaotic N-body systems, Barnes–Hut reproduces DirectSolver dynamics qualitatively and remains numerically stable.
Observed deviations are consistent with known approximation errors and chaotic sensitivity, not integrator failure.

Next actions:
- Sweep θ to study accuracy vs approximation strength.
- Validate stability across multiple random seeds.
- Proceed to performance-focused testing (Phase 5).








DATE: 18/12/25

Integrator: Leapfrog (Velocity Verlet)
Solvers: Direct O(N²) vs Barnes–Hut Octree (θ = 0.3)

dt, steps, softening: dt = 2e-3, steps = 2000, softening = 1e-3

Scenario:
Random 3D N-body system (N = 15, seed = 42) with random initial positions, velocities, and masses.
Same initial conditions used for both solvers.

Expected:
- Decreasing θ should increase accuracy (Barnes–Hut closer to Direct), at the cost of more tree traversal.
- Energy remains bounded but may show step-like changes due to close encounters.
- Angular momentum: Direct nearly constant; Barnes–Hut should improve vs larger θ but still not perfectly conserved.
- Linear momentum and COM: Barnes–Hut should track Direct more closely as θ decreases.

Observed:
- Relative energy drift:
  Barnes–Hut (θ = 0.3) is significantly closer to Direct than θ = 0.7; both remain bounded.
- Angular momentum drift:
  Barnes–Hut shows bounded deviation; Direct remains essentially flat.
- |P(t)|:
  Barnes–Hut overlaps Direct closely after initialization.
- Center-of-mass drift:
  Barnes–Hut overlaps Direct closely over the full run.

Conclusion:
Reducing θ improves Barnes–Hut accuracy as expected, bringing invariants and drift behavior closer to the DirectSolver baseline.
System remains stable under Leapfrog, and deviations are consistent with controlled approximation error.

Next actions:
- Repeat θ sweep for θ = 0.5 and θ = 1.0 using the same N/seed.
- Record how energy/ang-momentum drift change with θ to characterize accuracy vs approximation strength.








DATE: 18/12/25

Integrator: Leapfrog (Velocity Verlet)
Solvers: Direct O(N²) vs Barnes–Hut Octree (θ = 0.5)

dt, steps, softening: dt = 2e-3, steps = 2000, softening = 1e-3

Scenario:
Random 3D N-body system (N = 15, seed = 42) with random initial positions, velocities, and masses.
Same initial conditions used for both solvers.

Expected:
- Barnes–Hut accuracy should lie between θ = 0.3 and θ = 0.7 cases.
- Energy remains bounded with step-like changes during close encounters.
- Angular momentum conservation improves as θ decreases.
- Center-of-mass drift remains small and approximately linear.

Observed:
- Relative energy drift:
  Barnes–Hut (θ = 0.5) shows bounded deviation, intermediate between θ = 0.3 and θ = 0.7.
- Angular momentum drift:
  Bounded fluctuations (~10⁻³–10⁻²), smaller than θ = 0.7 and larger than θ = 0.3.
- |P(t)|:
  Small bounded noise relative to DirectSolver.
- Center-of-mass drift:
  Closely tracks DirectSolver with slightly increased slope compared to θ = 0.3.

Conclusion:
The θ parameter cleanly controls the Barnes–Hut accuracy–approximation tradeoff.
All runs remain stable under Leapfrog integration, validating the solver’s correctness.

Next actions:
- Complete θ sweep with θ = 1.0.
- Summarize θ-dependent accuracy trends.
- Transition to Phase 5 (performance and scaling tests).









DATE: 18/12/25

Integrator: Leapfrog (Velocity Verlet)
Solvers: Direct O(N²) vs Barnes–Hut Octree (θ = 1.0)

dt, steps, softening: dt = 2e-3, steps = 2000, softening = 1e-3

Scenario:
Random 3D N-body system (N = 15, seed = 42) with random initial positions, velocities, and masses.
Same initial conditions used for both solvers.

Expected:
- Large θ should significantly increase approximation error.
- Energy remains bounded but deviates strongly from DirectSolver.
- Angular momentum and linear momentum conservation degrade due to force asymmetry.
- Center-of-mass drift increases with θ.

Observed:
- Relative energy drift:
  Barnes–Hut (θ = 1.0) shows large bounded deviations relative to DirectSolver.
- Angular momentum drift:
  Significant bounded drift (~10⁻¹), while Direct remains flat.
- |P(t)|:
  Barnes–Hut exhibits visible deviation from Direct but remains bounded.
- Center-of-mass drift:
  Barnes–Hut shows noticeably larger linear drift than DirectSolver.

Conclusion:
Large θ values increase Barnes–Hut approximation error while preserving overall numerical stability.
Results clearly demonstrate the accuracy–approximation tradeoff governed by θ and validate solver behavior.

Next actions:
- Summarize θ-dependent accuracy trends.
- Conclude Phase 4 (Barnes–Hut solver).
- Proceed to Phase 5: performance and scaling analysis.





Phase 6 (Profiling)
DATE: 01/01/2026

Integrator: Leapfrog (Velocity Verlet)
Solver: Direct O(N^2)
Profiling tool: Python cProfile + pstats

Scenario:
Random 3D N-body system used for Phase 6 profiling.
N = 300
Steps = 300
dt = 2e-3
Softening = 1e-3

Goal:
Before attempting any optimization, measure where runtime is actually spent
in the DirectSolver pipeline using a profiler instead of guessing.

Method:
A dedicated profiling script was added which runs a normal simulation and
records function-level runtime statistics using cProfile.
Results are sorted by cumulative time to identify the true performance
bottlenecks.

Key Observations (DirectSolver):

- Total runtime: ~95 seconds
- compute_accelerations (physics.py) dominates runtime:
  ~71 seconds cumulative, corresponding to the O(N^2) pairwise force loop.
- The solver.accelerations() call itself is negligible compared to the work
  done inside compute_accelerations.
- Leapfrog integration (step + synchronize) contributes a noticeable but
  secondary cost (~35 seconds cumulative), largely due to repeated acceleration
  evaluations.
- Diagnostic calculations (potential energy, synchronization, state copying)
  contribute non-trivial overhead but are not the primary bottleneck.
- Potential energy computation alone accounts for ~20 seconds cumulative.

Conclusion:
Profiling confirms that the DirectSolver bottleneck is overwhelmingly dominated
by the pairwise force calculation in compute_accelerations, as expected from
O(N^2) scaling.
However, diagnostic work and repeated acceleration calls inside Leapfrog also
represent secondary costs.

Next actions:
- Use this profiling result to guide Phase 6 optimization decisions.
- Focus first on reducing Python overhead in compute_accelerations.
- Consider the cost of diagnostics separately from force computation.



DATE: 01/01/2026

Integrator: Leapfrog (Velocity Verlet)
Solver: Barnes–Hut Octree (θ = 0.7)
Profiling tool: Python cProfile + pstats

Scenario:
Random 3D N-body system used for Phase 6 profiling.
N = 1000
Steps = 300
dt = 2e-3
Softening = 1e-3

Goal:
Measure where runtime is spent in the Barnes–Hut solver and compare it to the
DirectSolver profiling results, before attempting any optimization.

Method:
A dedicated profiling script was used to run a normal Barnes–Hut simulation
while recording function-level runtime statistics.
Results were sorted by cumulative time.

Key Observations (Barnes–Hut):

- Total runtime: ~1038 seconds (significantly slower than Direct profiling run).
- The dominant cost is OctreeNode.compute_accelerations:
  ~742 seconds cumulative.
- Tree traversal during force evaluation dominates runtime more than tree
  construction.
- Tree construction costs are visible but secondary:
  - insert(): ~30 seconds cumulative
  - subdivide() and child insertion appear frequently but are not the main cost.
- Leapfrog integration (step + synchronize) still contributes substantial cost
  due to repeated acceleration evaluations.
- Diagnostic computations (especially potential energy) remain expensive
  but are not the main bottleneck.
- Barnes–Hut introduces extremely large function call counts due to recursion
  and repeated node visits.

Conclusion:
Barnes–Hut runtime is dominated by recursive tree traversal during force
evaluation rather than by tree construction.
Although Barnes–Hut has better asymptotic scaling, the Python implementation
introduces very large overhead from recursion, object access, and function calls.

Next actions:
- Use profiling data to guide Phase 6 optimization.
- Focus on reducing overhead in tree traversal and force evaluation.
- Avoid premature algorithmic changes; target Python-level overhead first.




DATE: 05/01/2026

Integrator: Leapfrog (Velocity Verlet)
Profiling tool: Python cProfile + pstats
Diagnostics: Disabled
State history: Disabled

Purpose:
Re-run profiling with diagnostics and history disabled in order to isolate
solver and integrator costs without diagnostic overhead.


Direct Solver (Profiling Mode)

Configuration:
N = 300
Steps = 300
dt = 2e-3
Softening = 1e-3

Results:
- Total runtime: ~72 seconds
- Total function calls: ~5.5e5
- Runtime is dominated by physics.compute_accelerations.
- Leapfrog step and synchronize still contribute noticeable cost.
- Diagnostic functions no longer appear in the hotspot list.

Conclusion:
With diagnostics disabled, the DirectSolver profile clearly shows that almost
all runtime is spent in the pairwise force calculation, as expected from O(N^2)
scaling.


Barnes–Hut Solver (Profiling Mode)

Configuration:
N = 1000
Steps = 300
dt = 2e-3
Softening = 1e-3
Theta = 0.7

Results:
- Total runtime: ~760 seconds
- Total function calls: ~2.1e8 (with ~1.9e8 primitive calls)
- Runtime is dominated by octree.compute_accelerations.
- Tree construction (insert, subdivide, mass/COM updates) contributes secondary
  cost but is not dominant.
- Leapfrog synchronize remains a significant contributor due to repeated
  acceleration evaluations.
- Diagnostic overhead is effectively removed.

Conclusion:
Barnes–Hut runtime is dominated by recursive tree traversal during force
evaluation.
The large number of function calls explains why profiling Barnes–Hut is much
slower than DirectSolver under cProfile.

Next actions:
- Use these results to guide Phase 6 optimization.
- Focus first on reducing Python overhead in Barnes–Hut tree traversal.
- Avoid algorithmic changes; target local optimizations.



Optimisation Results moved to phase_6_performance.txt doc.